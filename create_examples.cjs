const fs = require('fs');
const path = require('path');

// Target directory
const dir = path.join(__dirname, 'contracts', 'examples');

// Ensure directory exists
if (!fs.existsSync(dir)){
    fs.mkdirSync(dir, { recursive: true });
}

// Data for 15 Contracts
const contracts = [
    { name: "FHE_Add.sol", content: `// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\nimport "@fhevm/solidity/contracts/utils/TFHE.sol";\ncontract FHE_Add {\n    function add(einput _a, bytes calldata _proofA, einput _b, bytes calldata _proofB) public {\n        euint32 a = TFHE.asEuint32(_a, _proofA);\n        euint32 b = TFHE.asEuint32(_b, _proofB);\n        euint32 result = TFHE.add(a, b);\n        TFHE.allow(result, msg.sender);\n    }\n}` },
    { name: "FHE_Sub.sol", content: `// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\nimport "@fhevm/solidity/contracts/utils/TFHE.sol";\ncontract FHE_Sub {\n    function sub(einput _a, bytes calldata _proofA, einput _b, bytes calldata _proofB) public {\n        euint32 a = TFHE.asEuint32(_a, _proofA);\n        euint32 b = TFHE.asEuint32(_b, _proofB);\n        euint32 result = TFHE.sub(a, b);\n        TFHE.allow(result, msg.sender);\n    }\n}` },
    { name: "FHE_Mul.sol", content: `// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\nimport "@fhevm/solidity/contracts/utils/TFHE.sol";\ncontract FHE_Mul {\n    function mul(einput _a, bytes calldata _proofA, einput _b, bytes calldata _proofB) public {\n        euint32 a = TFHE.asEuint32(_a, _proofA);\n        euint32 b = TFHE.asEuint32(_b, _proofB);\n        euint32 result = TFHE.mul(a, b);\n        TFHE.allow(result, msg.sender);\n    }\n}` },
    { name: "FHE_Div.sol", content: `// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\nimport "@fhevm/solidity/contracts/utils/TFHE.sol";\ncontract FHE_Div {\n    function div(einput _a, bytes calldata _proofA, einput _b, bytes calldata _proofB) public {\n        euint32 a = TFHE.asEuint32(_a, _proofA);\n        euint32 b = TFHE.asEuint32(_b, _proofB);\n        euint32 result = TFHE.div(a, b);\n        TFHE.allow(result, msg.sender);\n    }\n}` },
    { name: "FHE_Rem.sol", content: `// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\nimport "@fhevm/solidity/contracts/utils/TFHE.sol";\ncontract FHE_Rem {\n    function rem(einput _a, bytes calldata _proofA, einput _b, bytes calldata _proofB) public {\n        euint32 a = TFHE.asEuint32(_a, _proofA);\n        euint32 b = TFHE.asEuint32(_b, _proofB);\n        euint32 result = TFHE.rem(a, b);\n        TFHE.allow(result, msg.sender);\n    }\n}` },
    { name: "FHE_And.sol", content: `// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\nimport "@fhevm/solidity/contracts/utils/TFHE.sol";\ncontract FHE_And {\n    function bitwiseAnd(einput _a, bytes calldata _proofA, einput _b, bytes calldata _proofB) public {\n        euint32 a = TFHE.asEuint32(_a, _proofA);\n        euint32 b = TFHE.asEuint32(_b, _proofB);\n        euint32 result = TFHE.and(a, b);\n        TFHE.allow(result, msg.sender);\n    }\n}` },
    { name: "FHE_Or.sol", content: `// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\nimport "@fhevm/solidity/contracts/utils/TFHE.sol";\ncontract FHE_Or {\n    function bitwiseOr(einput _a, bytes calldata _proofA, einput _b, bytes calldata _proofB) public {\n        euint32 a = TFHE.asEuint32(_a, _proofA);\n        euint32 b = TFHE.asEuint32(_b, _proofB);\n        euint32 result = TFHE.or(a, b);\n        TFHE.allow(result, msg.sender);\n    }\n}` },
    { name: "FHE_Xor.sol", content: `// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\nimport "@fhevm/solidity/contracts/utils/TFHE.sol";\ncontract FHE_Xor {\n    function bitwiseXor(einput _a, bytes calldata _proofA, einput _b, bytes calldata _proofB) public {\n        euint32 a = TFHE.asEuint32(_a, _proofA);\n        euint32 b = TFHE.asEuint32(_b, _proofB);\n        euint32 result = TFHE.xor(a, b);\n        TFHE.allow(result, msg.sender);\n    }\n}` },
    { name: "FHE_Eq.sol", content: `// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\nimport "@fhevm/solidity/contracts/utils/TFHE.sol";\ncontract FHE_Eq {\n    function checkEq(einput _a, bytes calldata _proofA, einput _b, bytes calldata _proofB) public {\n        euint32 a = TFHE.asEuint32(_a, _proofA);\n        euint32 b = TFHE.asEuint32(_b, _proofB);\n        ebool result = TFHE.eq(a, b);\n        TFHE.allow(result, msg.sender);\n    }\n}` },
    { name: "FHE_Ne.sol", content: `// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\nimport "@fhevm/solidity/contracts/utils/TFHE.sol";\ncontract FHE_Ne {\n    function checkNe(einput _a, bytes calldata _proofA, einput _b, bytes calldata _proofB) public {\n        euint32 a = TFHE.asEuint32(_a, _proofA);\n        euint32 b = TFHE.asEuint32(_b, _proofB);\n        ebool result = TFHE.ne(a, b);\n        TFHE.allow(result, msg.sender);\n    }\n}` },
    { name: "FHE_Gt.sol", content: `// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\nimport "@fhevm/solidity/contracts/utils/TFHE.sol";\ncontract FHE_Gt {\n    function checkGt(einput _a, bytes calldata _proofA, einput _b, bytes calldata _proofB) public {\n        euint32 a = TFHE.asEuint32(_a, _proofA);\n        euint32 b = TFHE.asEuint32(_b, _proofB);\n        ebool result = TFHE.gt(a, b);\n        TFHE.allow(result, msg.sender);\n    }\n}` },
    { name: "FHE_Lt.sol", content: `// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\nimport "@fhevm/solidity/contracts/utils/TFHE.sol";\ncontract FHE_Lt {\n    function checkLt(einput _a, bytes calldata _proofA, einput _b, bytes calldata _proofB) public {\n        euint32 a = TFHE.asEuint32(_a, _proofA);\n        euint32 b = TFHE.asEuint32(_b, _proofB);\n        ebool result = TFHE.lt(a, b);\n        TFHE.allow(result, msg.sender);\n    }\n}` },
    { name: "FHE_Gte.sol", content: `// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\nimport "@fhevm/solidity/contracts/utils/TFHE.sol";\ncontract FHE_Gte {\n    function checkGte(einput _a, bytes calldata _proofA, einput _b, bytes calldata _proofB) public {\n        euint32 a = TFHE.asEuint32(_a, _proofA);\n        euint32 b = TFHE.asEuint32(_b, _proofB);\n        ebool result = TFHE.ge(a, b);\n        TFHE.allow(result, msg.sender);\n    }\n}` },
    { name: "FHE_Lte.sol", content: `// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\nimport "@fhevm/solidity/contracts/utils/TFHE.sol";\ncontract FHE_Lte {\n    function checkLte(einput _a, bytes calldata _proofA, einput _b, bytes calldata _proofB) public {\n        euint32 a = TFHE.asEuint32(_a, _proofA);\n        euint32 b = TFHE.asEuint32(_b, _proofB);\n        ebool result = TFHE.le(a, b);\n        TFHE.allow(result, msg.sender);\n    }\n}` },
    { name: "FHE_Mux.sol", content: `// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\nimport "@fhevm/solidity/contracts/utils/TFHE.sol";\ncontract FHE_Mux {\n    function mux(einput _controlBit, bytes calldata _proofBit, einput _a, bytes calldata _proofA, einput _b, bytes calldata _proofB) public {\n        ebool control = TFHE.asEbool(_controlBit, _proofBit);\n        euint32 a = TFHE.asEuint32(_a, _proofA);\n        euint32 b = TFHE.asEuint32(_b, _proofB);\n        euint32 result = TFHE.select(control, a, b);\n        TFHE.allow(result, msg.sender);\n    }\n}` }
];

console.log(`Creating 15 FHE Example contracts in ${dir}...`);
contracts.forEach(contract => {
    fs.writeFileSync(path.join(dir, contract.name), contract.content);
    console.log(`âœ… Created ${contract.name}`);
});
console.log("\nAll files created successfully!");
